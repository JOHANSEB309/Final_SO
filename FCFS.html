<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <title>Planificador FCFS (First Come, First Served)</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
        background-color: #f0f2f5;
      }

      .container {
        background-color: white;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }

      h1,
      h2 {
        color: #1a73e8;
      }

      .input-section {
        margin-bottom: 20px;
        padding: 15px;
        background-color: #f8f9fa;
        border-radius: 8px;
      }

      .input-group {
        display: flex;
        gap: 10px;
        margin-bottom: 10px;
        align-items: center;
      }

      input {
        padding: 8px;
        border: 1px solid #ddd;
        border-radius: 4px;
        width: 120px;
      }

      button {
        padding: 8px 16px;
        background-color: #1a73e8;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        transition: background-color 0.2s;
      }

      button:hover {
        background-color: #1557b0;
      }

      .gantt-chart {
        margin-top: 20px;
        border: 1px solid #ddd;
        padding: 20px;
        border-radius: 8px;
        background-color: white;
      }

      .process-bar {
        height: 40px;
        margin: 5px 0;
        display: flex;
        align-items: center;
      }

      .process-segment {
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        margin-right: 1px;
      }

      .process-segment.idle {
        background-color: gray; /* CPU libre */
      }

      .process-segment.waiting {
        background-color: gray; /* En espera */
      }

      .process-segment.running {
        background-color: green; /* En ejecución */
      }

      .process-segment.blocked {
        background-color: red; /* En ejecución */
      }

      .timeline {
        display: flex;
        margin-top: 10px;
        border-top: 1px solid #ddd;
        padding-top: 5px;
      }

      .time-marker {
        flex: 1;
        text-align: left;
        font-size: 12px;
        color: #666;
      }

      .results {
        margin-top: 20px;
        padding: 15px;
        background-color: white;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }

      table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 15px;
      }

      th,
      td {
        border: 1px solid #ddd;
        padding: 8px;
        text-align: left;
      }

      th {
        background-color: #f8f9fa;
        color: #1a73e8;
      }

      .process-list {
        margin-top: 20px;
        background-color: white;
        padding: 15px;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }

      .process-item {
        display: flex;
        gap: 10px;
        margin-bottom: 5px;
        padding: 10px;
        background-color: #f8f9fa;
        border-radius: 4px;
        align-items: center;
      }

      .metrics {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 15px;
        margin-top: 20px;
        padding: 15px;
        background-color: #f8f9fa;
        border-radius: 8px;
      }

      .metric-card {
        background-color: white;
        padding: 15px;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }

      .metric-title {
        color: #1a73e8;
        font-weight: bold;
        margin-bottom: 5px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>Planificador FCFS (First Come, First Served)</h1>

      <div class="input-section">
        <h2>Agregar Proceso</h2>
        <div class="input-group">
          <input
            type="text"
            id="processName"
            placeholder="Nombre del proceso"
          />
          <input
            type="number"
            id="arrivalTime"
            placeholder="Tiempo de llegada"
          />
          <input
            type="number"
            id="burstTime"
            placeholder="Tiempo de Ejecución"
          />
          <input
            type="number"
            id="arrivalBlock"
            placeholder="Inicio de Bloqueo"
          />
          <input type="number" id="blockTime" placeholder="Tiempo de Bloqueo" />

          <button onclick="addProcess()">Agregar Proceso</button>
        </div>
      </div>

      <div class="process-list" id="processList">
        <h2>Procesos Ingresados</h2>
      </div>
      <button onclick="calculateFCFS()">Calcular FCFS</button>

      <div class="results" id="results">
        <h2>Resultados Detallados</h2>
        <div class="metrics" id="metrics"></div>
        <table id="resultsTable">
          <thead>
            <tr>
              <th>Proceso</th>
              <th>Llegada</th>
              <th>Ejecución</th>
              <th>Bloqueo Inicio</th>
              <th>Bloqueo Duración</th>
              <th>Comienzo</th>
              <th>Final</th>
              <th>Retorno</th>
              <th>Espera</th>
              <th>T. Perdido</th>
              <th>Penalidad</th>
              <th>Respuesta</th>
            </tr>
          </thead>
          <tbody id="resultsTableBody"></tbody>
        </table>
      </div>

      <div class="gantt-chart" id="ganttChart">
        <h2>Diagrama de Gantt</h2>
        <div id="ganttBars"></div>
        <div id="timeline" class="timeline"></div>
      </div>
    </div>

    <script>
      let processes = [];

      function addProcess() {
        const name = document.getElementById("processName").value;
        const arrivalTime = parseInt(
          document.getElementById("arrivalTime").value
        );
        const burstTime = parseInt(document.getElementById("burstTime").value);
        const arrivalBlock = parseInt(
          document.getElementById("arrivalBlock").value
        );
        const blockTime = parseInt(document.getElementById("blockTime").value);

        if (
          !name ||
          isNaN(arrivalTime) ||
          isNaN(burstTime) ||
          isNaN(arrivalBlock) ||
          isNaN(blockTime)
        ) {
          alert("Por favor, complete todos los campos correctamente");
          return;
        }

        processes.push({
          name,
          arrivalTime,
          burstTime,
          arrivalBlock,
          blockTime,
          completed: false,
        });

        updateProcessList();
        clearInputs();
      }

      function clearInputs() {
        document.getElementById("processName").value = "";
        document.getElementById("arrivalTime").value = "";
        document.getElementById("burstTime").value = "";
        document.getElementById("arrivalBlock").value = "";
        document.getElementById("blockTime").value = "";
      }

      function updateProcessList() {
        const processList = document.getElementById("processList");
        processList.innerHTML = "<h2>Procesos Ingresados</h2>";

        processes.forEach((process, index) => {
          const processItem = document.createElement("div");
          processItem.className = "process-item";
          processItem.innerHTML = `
                          <span>Proceso: ${process.name}</span>
                          <span>Llegada: ${process.arrivalTime}</span>
                          <span>Ráfaga: ${process.burstTime}</span>
                          <span>Inicio Bloqueo: ${process.arrivalBlock}</span>
                          <span>Duración Bloqueo: ${process.blockTime}</span>
                          <button onclick="removeProcess(${index})">Eliminar</button>
                      `;
          processList.appendChild(processItem);
        });
      }

      function removeProcess(index) {
        processes.splice(index, 1);
        updateProcessList();
      }

      function calculateFCFS() {
        if (processes.length === 0) {
          alert("Agregue al menos un proceso");
          return;
        }

        let processQueue = JSON.parse(JSON.stringify(processes)); // Copia profunda
        let time = 0;
        let ready = [];
        let blocked = [];
        let completed = [];
        let runningProcess = null;

        while (
          ready.length > 0 ||
          blocked.length > 0 ||
          runningProcess ||
          processQueue.length > 0
        ) {
          console.log(`Time: ${time}`);

          ready.push(processQueue[0]);
          // 1. Agregar procesos que han llegado a la cola de listos
          for (let i = 0; i < processQueue.length; i++) {
            if (processQueue[i].arrivalTime === time) {
              ready.push(processQueue[i]);
              console.log(
                `Process ${processQueue[i].name} arrived and added to ready queue.`
              );
              processQueue.splice(i, 1);
              i--; // Ajustar el índice tras eliminar
            }
          }

          // 2. Revisar si algún proceso se desbloquea
          for (let i = 0; i < blocked.length; i++) {
            if (blocked[i].unblockTime === time) {
              ready.push(blocked[i]);
              console.log(
                `Process ${blocked[i].name} unblocked and moved to ready queue.`
              );
              blocked.splice(i, 1);
              i--;
            }
          }

          // 3. Si no hay un proceso ejecutando, tomar el primero de la cola de listos
          if (!runningProcess && ready.length > 0) {
            runningProcess = ready.shift();
            runningProcess.state = "running";
            console.log(`Process ${runningProcess.id} started execution.`);
          }

          // 4. Ejecutar el proceso en CPU
          if (runningProcess) {
            runningProcess.remainingTime--;

            // Si el proceso se bloquea
            if (
              runningProcess.blockTime === time &&
              runningProcess.remainingTime > 0
            ) {
              console.log(`Process ${runningProcess.id} blocked.`);
              runningProcess.unblockTime = time + 2; // Se desbloqueará después de 2 unidades de tiempo
              blocked.push(runningProcess);
              runningProcess = null;
            }
            // Si el proceso finaliza
            else if (runningProcess.remainingTime === 0) {
              console.log(`Process ${runningProcess.id} finished.`);
              completed.push(runningProcess);
              runningProcess = null;
            }
          }

          // 5. Si no hay procesos listos o en ejecución, avanzar al siguiente evento importante
          if (!runningProcess && ready.length === 0 && blocked.length > 0) {
            time = Math.min(...blocked.map((p) => p.unblockTime));
          } else {
            time++;
          }
        }

        console.log("All processes have completed execution.");
      }

      /*function calculateFCFS() {
        if (processes.length === 0) {
          alert("Agregue al menos un proceso");
          return;
        }

        let processQueue = JSON.parse(JSON.stringify(processes));
        let currentTime = 0;
        let ready = [processQueue];
        let aux = [];
        let blocked = [];
        let completed = [];
        let timeline = [];
        let i = 0;

        // Ordenar procesos por tiempo de llegada (FCFS)
        processQueue.sort((a, b) => a.arrivalTime - b.arrivalTime);

        do {
          
          let selectedProcess = processQueue[i];

          console.log(selectedProcess.name);

          // Si hay tiempo ocioso antes de ejecutar el proceso
          /*if (selectedProcess.arrivalTime > currentTime) {
        timeline.push({
          name: "Libre", // Tiempo donde la CPU está libre
          start: currentTime,
          duration: selectedProcess.arrivalTime - currentTime,
          state: "idle",
        });
        currentTime = selectedProcess.arrivalTime;
      }

          // Calcular métricas
          selectedProcess.startTime = currentTime;
          selectedProcess.completionTime =
            currentTime + selectedProcess.burstTime;
          selectedProcess.turnaroundTime =
            selectedProcess.completionTime - selectedProcess.arrivalTime;
          selectedProcess.waitingTime =
            selectedProcess.turnaroundTime - selectedProcess.burstTime;
          selectedProcess.lostTime =
            selectedProcess.startTime - selectedProcess.arrivalTime;
          selectedProcess.penalty =
            selectedProcess.turnaroundTime / selectedProcess.burstTime;
          selectedProcess.responseTime =
            selectedProcess.startTime - selectedProcess.arrivalTime;

          // Si el proceso tuvo que esperar (excluyendo el primer proceso en ejecutarse)
          if (selectedProcess.waitingTime > 0 && i !== 0) {
            timeline.push({
              name: selectedProcess.name + " (En Espera)",
              start: selectedProcess.arrivalTime,
              duration: selectedProcess.startTime - selectedProcess.arrivalTime,
              state: "waiting",
            });
          }

          if (blocked.includes(selectedProcess)) {
            console.log("si");
            timeline.push({
              name: selectedProcess.name,
              start: currentTime,
              duration: selectedProcess.burstTime,
              state: "running",
            });
            blocked.splice(selectedProcess);
          }

          if (selectedProcess.arrivalBlock != 0) {
            timeline.push({
              name: selectedProcess.name,
              start: currentTime,
              duration:
                selectedProcess.burstTime - selectedProcess.arrivalBlock,
              state: "running",
            });

            timeline.push({
              name: selectedProcess.name,
              start: selectedProcess.burstTime - selectedProcess.arrivalBlock,
              duration: selectedProcess.blockTime,
              state: "blocked",
            });

            selectedProcess.burstTime =
              selectedProcess.burstTime - selectedProcess.arrivalBlock;
            blocked.push(selectedProcess);
          } else {
            console.log('arrivalblock = 0');
            timeline.push({
              name: selectedProcess.name,
              start: currentTime,
              duration: selectedProcess.burstTime,
              state: "running",
            });
            currentTime = selectedProcess.completionTime;
            completed.push(selectedProcess);
          }

          
          blocked.shift();

          i++;

          displayResults(completed);
          drawGanttChart(timeline);
        } while (ready.length !== 0 && blocked.length!==0);
      }*/

      function displayResults(completed) {
        const tbody = document.getElementById("resultsTableBody");
        tbody.innerHTML = "";

        // Calcular promedios
        let totalTurnaround = 0;
        let totalWaiting = 0;
        let totalLostTime = 0;
        let totalPenalty = 0;
        let totalResponse = 0;

        completed.forEach((process) => {
          const row = document.createElement("tr");
          row.innerHTML = `
                          <td>${process.name}</td>
                          <td>${process.arrivalTime}</td>
                          <td>${process.burstTime}</td>
                          <td>${process.arrivalBlock}</td>
                          <td>${process.blockTime}</td>
                          <td>${process.startTime}</td>
                          <td>${process.completionTime}</td>
                          <td>${process.turnaroundTime}</td>
                          <td>${process.waitingTime}</td>
                          <td>${process.lostTime}</td>
                          <td>${process.penalty.toFixed(2)}</td>
                          <td>${process.responseTime}</td>
                      `;
          tbody.appendChild(row);

          totalTurnaround += process.turnaroundTime;
          totalWaiting += process.waitingTime;
          totalLostTime += process.lostTime;
          totalPenalty += process.penalty;
          totalResponse += process.responseTime;
        });

        // Mostrar métricas promedio
        const metrics = document.getElementById("metrics");
        metrics.innerHTML = `
                      <div class="metric-card">
                          <div class="metric-title">Tiempo de Retorno Promedio</div>
                          <div>${(totalTurnaround / completed.length).toFixed(
                            2
                          )}</div>
                      </div>
                      <div class="metric-card">
                          <div class="metric-title">Tiempo de Espera Promedio</div>
                          <div>${(totalWaiting / completed.length).toFixed(
                            2
                          )}</div>
                      </div>
                      <div class="metric-card">
                          <div class="metric-title">Tiempo Perdido Promedio</div>
                          <div>${(totalLostTime / completed.length).toFixed(
                            2
                          )}</div>
                      </div>
                      <div class="metric-card">
                          <div class="metric-title">Penalidad Promedio</div>
                          <div>${(totalPenalty / completed.length).toFixed(
                            2
                          )}</div>
                      </div>
                      <div class="metric-card">
                          <div class="metric-title">Tiempo de Respuesta Promedio</div>
                          <div>${(totalResponse / completed.length).toFixed(
                            2
                          )}</div>
                      </div>
                  `;
      }

      function drawGanttChart(timeline) {
        const ganttBars = document.getElementById("ganttBars");
        const timelineDiv = document.getElementById("timeline");
        ganttBars.innerHTML = "";
        timelineDiv.innerHTML = "";

        const totalTime =
          timeline[timeline.length - 1].start +
          timeline[timeline.length - 1].duration;
        const timeScale = 100 / totalTime;

        timeline.forEach((item) => {
          const bar = document.createElement("div");
          bar.className = "process-bar";

          const segment = document.createElement("div");
          segment.className = `process-segment ${item.state}`;
          segment.style.width = `${item.duration * timeScale}%`;
          segment.style.marginLeft = `${item.start * timeScale}%`;
          segment.textContent = item.name;

          bar.appendChild(segment);
          ganttBars.appendChild(bar);
        });

        // Crear marcadores de tiempo
        for (let i = 0; i <= totalTime; i++) {
          const marker = document.createElement("div");
          marker.className = "time-marker";
          marker.style.flex = `0 0 ${timeScale}%`;
          marker.textContent = i;
          timelineDiv.appendChild(marker);
        }
      }
    </script>
  </body>
</html>
